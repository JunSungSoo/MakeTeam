# 프론트엔드 디렉토리 구조 비교

최근 React/TypeScript 프론트엔드 프로젝트에서 자주 사용되는 디렉토리 구조 패턴들을 정리한다.

---

## 1. 기능 기반 구조 (Feature-based / Feature-sliced)

```
src/
├── features/
│   ├── auth/
│   │   ├── components/
│   │   ├── hooks/
│   │   ├── stores/
│   │   ├── types/
│   │   └── api/
│   ├── dashboard/
│   │   ├── components/
│   │   ├── hooks/
│   │   └── ...
│   └── team/
│       └── ...
├── shared/
│   ├── components/
│   ├── hooks/
│   └── utils/
└── app/
    ├── routes/
    └── providers/
```

### 장점
- **높은 응집도**: 관련 코드가 한 폴더에 모여 있어 기능 파악이 빠르다
- **확장성**: 기능 추가 시 독립적인 폴더만 추가하면 된다
- **팀 분업**: 기능 단위로 개발자 할당이 용이하다
- **삭제 용이**: 기능 제거 시 폴더 하나만 삭제하면 된다

### 단점
- **초기 오버헤드**: 작은 프로젝트에서는 폴더가 과도하게 많아진다
- **공통 코드 위치 모호**: 여러 기능에서 공유하는 코드의 위치를 정하기 어렵다
- **일관성 유지 어려움**: 팀원마다 기능 범위를 다르게 해석할 수 있다

### 적합한 경우
- 중~대규모 프로젝트
- 도메인이 명확히 구분되는 프로젝트
- 여러 팀이 동시에 작업하는 환경

---

## 2. 레이어 기반 구조 (Layer-based) ← 본 프로젝트 채택

```
src/
├── components/
│   ├── ui/
│   ├── common/
│   └── layout/
├── pages/
├── hooks/
├── stores/
├── services/
├── types/
├── utils/
└── constants/
```

### 장점
- **직관적**: 파일의 역할만으로 위치를 알 수 있다
- **낮은 진입장벽**: 새로운 팀원이 구조를 빠르게 이해한다
- **간결함**: 소규모 프로젝트에서 불필요한 복잡성이 없다
- **관례적**: 대부분의 튜토리얼과 보일러플레이트가 이 구조를 사용한다

### 단점
- **낮은 응집도**: 하나의 기능 관련 파일이 여러 폴더에 흩어진다
- **확장 시 복잡도 증가**: 프로젝트가 커지면 각 디렉토리 내 파일 수가 많아진다
- **의존성 방향 불명확**: 레이어 간 의존 규칙을 별도로 정해야 한다

### 적합한 경우
- 소~중규모 프로젝트
- 빠른 MVP 개발
- 도메인이 단순하거나 아직 확정되지 않은 초기 단계

---

## 3. Atomic Design 구조

```
src/
├── components/
│   ├── atoms/         # Button, Input, Label 등 최소 단위
│   ├── molecules/     # SearchBar, FormField 등 조합
│   ├── organisms/     # Header, Sidebar 등 독립 섹션
│   ├── templates/     # 페이지 레이아웃 골격
│   └── pages/         # 실제 데이터가 연결된 페이지
├── hooks/
├── stores/
└── utils/
```

### 장점
- **체계적인 컴포넌트 계층**: 컴포넌트 크기와 책임이 명확하다
- **재사용성 극대화**: 작은 단위부터 조합하므로 재사용이 자연스럽다
- **디자인 시스템 친화적**: 디자이너와 협업 시 공통 언어가 된다

### 단점
- **분류 기준 모호**: atom과 molecule의 경계가 주관적이다
- **과도한 추상화**: 간단한 UI에도 여러 계층을 거쳐야 한다
- **학습 비용**: 팀원 전체가 패턴을 이해해야 일관성을 유지한다

### 적합한 경우
- 디자인 시스템을 자체 구축하는 프로젝트
- UI 컴포넌트 라이브러리를 제공하는 프로젝트
- 디자이너와의 긴밀한 협업이 필요한 경우

---

## 4. Feature-Sliced Design (FSD)

```
src/
├── app/               # 앱 초기화, 프로바이더, 라우팅
├── processes/         # 복합 비즈니스 프로세스 (선택)
├── pages/             # 라우트별 페이지
├── widgets/           # 독립적인 UI 블록 (Header, Sidebar)
├── features/          # 사용자 상호작용 기능 (로그인, 좋아요)
├── entities/          # 비즈니스 엔티티 (User, Team, Project)
└── shared/            # 공유 유틸, UI, API, 타입
```

### 장점
- **엄격한 의존성 규칙**: 상위 레이어만 하위를 import (단방향 의존성)
- **확장성**: 대규모 프로젝트에서도 구조가 유지된다
- **팀 협업 최적화**: 레이어별로 담당자 분리가 가능하다
- **표준화**: 명확한 규칙으로 코드 리뷰와 온보딩이 수월하다

### 단점
- **높은 학습 비용**: 7개 레이어의 역할을 모두 이해해야 한다
- **보일러플레이트**: 작은 기능도 정해진 구조를 따라야 한다
- **소규모 프로젝트에 과잉**: 간단한 앱에는 오버 엔지니어링이다

### 적합한 경우
- 대규모 엔터프라이즈 프로젝트
- 장기 유지보수가 필요한 프로젝트
- 10명 이상의 프론트엔드 팀

---

## 5. 모듈 기반 구조 (Module-based)

```
src/
├── modules/
│   ├── auth/
│   │   ├── AuthPage.tsx
│   │   ├── useAuth.ts
│   │   ├── auth.store.ts
│   │   ├── auth.api.ts
│   │   └── auth.types.ts
│   └── team/
│       └── ...
├── core/              # 앱 핵심 (라우터, 프로바이더)
├── shared/            # 공유 리소스
└── ui/                # UI 라이브러리
```

### 장점
- **자급자족 모듈**: 각 모듈이 독립적으로 동작 가능하다
- **Feature-based보다 단순**: 내부 구조를 강제하지 않아 유연하다
- **점진적 마이그레이션**: 기존 프로젝트에서 점진적으로 전환 가능하다

### 단점
- **모듈 간 통신 규칙 필요**: 이벤트나 공유 스토어 등 별도 규칙이 필요하다
- **모듈 크기 관리**: 모듈이 비대해질 수 있다

### 적합한 경우
- 마이크로 프론트엔드를 고려하는 프로젝트
- 중규모 프로젝트
- 점진적으로 구조를 개선하고 싶을 때

---

## 본 프로젝트의 선택: 레이어 기반 구조

### 선택 이유
1. **프로젝트 초기 단계**이므로 간결하고 직관적인 구조가 적합
2. **도메인이 확정되지 않은 상태**에서 기능 기반으로 나누면 리팩토링 비용 발생
3. shadcn/ui가 `components/ui/` 구조를 기본으로 사용하므로 자연스러운 통합
4. 프로젝트 규모가 커지면 **Feature-based 구조로 점진적 전환 가능**

### 마이그레이션 전략
프로젝트가 성장하여 `pages/`나 `components/common/`에 파일이 20개 이상 쌓이면, Feature-based 구조로의 전환을 검토한다:
1. 도메인별 feature 폴더 생성
2. 관련 컴포넌트, 훅, 스토어를 feature 폴더로 이동
3. `shared/`에 공통 코드 유지
